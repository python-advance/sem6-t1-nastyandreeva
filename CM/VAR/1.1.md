Исследовать функционал одного модуля не из стандартной библиотеки (например, joblib) и создать фрагмент ЭОР с описанием и примерами его использования при работе в Jupyter Notebook и в скриптах. Для выполнения задания использовать Jupyter Notebook, опубликовать результат выполнения задания в портфолио в HTML и PDF формате.
***
*SymPy* - это активно развивающаяся библиотека для символьных вычислений в Python. SymPy полностью написан на Python и не требует сторонних библиотек. Данное руководство является кратким и представляет из себя введение в SymPy. В нем вы узнаете об основных возможностях SymPy.Если же вы желаете прочитать более подробное руководство, то обратитесь к [Руководству пользователя SymPy](http://www.asmeurer.com/sympy_doc/dev-py3k/guide.html),[Описанию модулей SymPy](http://www.asmeurer.com/sympy_doc/dev-py3k/modules/index.html), можно также обратиться и к [исходному коду](https://github.com/sympy/sympy/) библиотеки. 
***
### С чего же начать?
Для начала нам необходимо скачать SymPy, сделать это проще всего [отсюда](https://code.google.com/archive/p/sympy/). Для Windows-систем, нужно скачать и запустить установочный .exe файл. В POSIX-совместимых системах нужно скачать .tar.gz файл и распаковать его. Далее запускаем из интерпретатора Python:
```python
$ cd sympy-0.5.12
$ python
```
Для импорта модуля пишем обычну команду импорта, и сразу же включаем красивый вывод
```python
In [1]:   from sympy import *
          init_printing()
```
Основными кирпичиками, из которых строятся выражения, являются символы. Символ имеет имя, которое используется при печати выражений. Объекты класса Symbol нужно создавать и присваивать переменным питона, чтобы их можно было использовать. В принципе, имя символа и имя переменной, которой мы присваиваем этот символ - две независимые вещи, и можно написать abc=Symbol('xyz'). Но тогда при вводе программы Вы будете использовать abc, а при печати результатов SymPy будет использовать xyz, что приведёт к ненужной путанице. Поэтому лучше, чтобы имя символа совпадало с именем переменной питона, которой он присваивается.

В языках, специально предназначенных для символьных вычислений, таких, как Mathematica, если Вы используете переменную, которой ничего не было присвоено, то она автоматически воспринимается как символ с тем же именем. Питон не был изначально предназначен для символьных вычислений. Если Вы используете переменную, которой ничего не было присвоено, Вы получите сообщение об ошибке. Объекты типа Symbol нужно создавать явно.
### Переменные. Многочлены и рациональные функции
```python
In [2]:   x=Symbol('x')
```
```python
In [3]:   a=x**2-1
          a
```
```python
Out [3]:   x²−1
```
Можно определить несколько символов одновременно. Строка разбивается на имена по пробелам.
```python
In [4]:  y,z=symbols('y z')
```
Подставим вместо  x  выражение  y+1 .
```python
In [5]:  a.subs(x,y+1)
```
```python
Out [5]:   (y+1)²−1
```
Экземпляры класса Symbol взаимодействуют друг с другом. Таким образом, с помощью них конструируются алгебраические выражения:
```python
In [6]:  x + y + x - y
```
```python
Out [6]:   2*x
```
SymPy не раскрывает скобки автоматически. Для этого используется функция expand.
```python
In [7]:  ((x + y)**2).expand()
```
```python
Out [7]:  x² + 2*x*y + y²
```
Переменные могут быть заменены на другие переменные, числа или выражения с помощью функции подстановки subs(old, new):
```python
In [8]: ((x + y)²).subs(x, 1)
```
```python
Out [8]:  (y + 1)²
```
Чтобы разложить выражение на простейшие дроби используется функция apart(expr, x):
```python
In [9]: apart((x + 1)/(x - 1), x)
```
```python
Out [9]:        2
          1 + -----
              x - 1
```
Чтобы снова привести дробь к общему знаменателю используется функция together(expr, x):
```python
In [10]: together(1/x + 1/y + 1/z)
```
```python
Out [10]:        
          x*y + x*z + y*z
          ---------------
               x*y*z
```
### Элементарные функции

SymPy автоматически применяет упрощения элементарных функция (которые справедливы во всех случаях).
```python
In [11]:  sin(-x)
```
```python
Out [11]:  −sin(x)
```
SymPy может работать с числами с плавающей точкой, имеющими сколь угодно большую точность. Вот  π  с 100 значащими цифрами.
```python
In [12]:  pi.n(100)
```
```python
Out [12]:  3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068
```
E - это основание натуральных логарифмов.
SymPy автоматически применяет упрощения элементарных функция (которые справедливы во всех случаях).
```python
In [13]:  log(1),log(E)
```
```python
Out [13]:  (0,1)
```
Функция trigsimp пытается переписать тригонометрическое выражение в наиболее простом виде. В программах лучше использовать более специализированные функции.
```python
In [14]:  rigsimp(2*sin(x)**2+3*cos(x)**2)
```
```python
Out [14]:  cos²(x)+2
```
Функция expand_log преобразует логарифмы произведений и степеней в суммы логарифмов (только для положительных величин); logcombine производит обратное преобразование.
```python
In [15]:  a=expand_log(log(p*q**2))
          a
```
```python
Out [15]:  log(p)+2log(q)
```
```python
In [16]:  logcombine(a)
```
```python
Out [16]:  log(pq²)
```
### Структура выражений
Внутреннее представление выражения - это дерево. Функция srepr возвращает строку, представляющую его.
```python
In [17]:  srepr(x+1)
```
```python
Out [17]:  "Add(Symbol('x'), Integer(1))"
```
```python
In [18]:  srepr(x-1)
```
```python
Out [18]: "Add(Symbol('x'), Integer(-1))"
```
```python
In [19]:  srepr(x/y)
```
```python
Out [19]:  "Mul(Symbol('x'), Pow(Symbol('y'), Integer(-1)))"
```
Вместо бинарных операций +, * и т.д. можно использовать функции Add, Mul, Pow и т.д.
```python
In [20]:  Mul(x,Pow(y,-1))
```
```python
Out [20]:  x
           -
           y
```
```python
In [21]:  srepr(f(x,y))
```
```python
Out [21]:  "Function('f')(Symbol('x'), Symbol('y'))"
```
Атрибут func - это функция верхнего уровня в выражении, а args - список её аргументов.
```python
In [22]:  a=2*x*y**2
          a.func
```
```python
Out [22]:  sympy.core.mul.Mul
```
```python
In [23]:  a.args
```
```python
Out [23]:  (2,x,y²)
```
Метод replace ищет подвыражения, соответствующие образцу (содержащему произвольные переменные), и заменяет их на заданное выражение (оно может содержать те же произвольные переменные).
```python
In [24]:  (f(x,x)+f(x,y)).replace(f(a,a),a**2)
```
```python
Out [24]:  x²+f(x,y)
```
```python
In [25]:  a=x**2+y**2
          a.replace(x,x+1)
```
```python
Out [25]:  y²+(x+1)²
```
Соответствовать образцу должно целое подвыражение, это не может быть часть сомножителей в произведении или меньшая степеть в большей.
### Решение уравнений
```python
In [26]:  a,b,c,d,e,f=symbols('a b c d e f')
```
Уравнение записывается как функция Eq с двумя параметрами. Функция solve возврящает список решений.
```python
In [27]:  solve(Eq(a*x,b),x)
```
```python
Out [27]: [b/a]
```
 Впрочем, можно передать функции solve просто выражение. Подразумевается уравнение, что это выражение равно 0. Также можно решать квадратные уравнения, системы линейных уравнений.
### Дифференцирование
Продифференцировать любое выражение SymPy, можно используя diff(func, var). 
```python
In [28]:   x = Symbol('x')
           diff(sin(x), x)
```
```python
Out [28]: cos(x)
```
```python
In [29]:  diff(sin(2*x), x)
```
```python
Out 2*cos(2*x)
```
Для разложения в ряд используйте метод .series(var, point, order).
SymPy поддерживает вычисление определенных и неопределенных интегралов с помощью функции integrate(). Она использует расширенный алгоритм Риша-Нормана и некоторые шаблоны и эвристики. Можно вычислять интегралы трансцендентных, простых и специальных функций.
Помимо мнимой единицы I, которое является мнимым числом, символы тоже могут иметь специальные атрибуты (real, positive, complex и т.д), которые определяют поведение этих символов при вычислении символьных выражений. Также могут решаться различные тригонометрические, сферические функции, факториалы и гамма-функции.
